import { inngest } from "./inngest";
import { generateManimScript, generateVoiceoverScript } from "./gemini";
import { renderManimVideo } from "./e2b";
import { uploadVideo } from "./uploadthing";
import { jobStore } from "./job-store";
import { uploadToYouTube } from "./youtube";

function buildYouTubeTitle(params: {
  prompt?: string;
  voiceoverScript?: string;
}): string {
  const { prompt, voiceoverScript } = params;

  const sanitize = (input: string) =>
    input
      .replace(/[\r\n]+/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .replace(/[\p{Cf}\u0000-\u001F]/gu, "");

  const capitalize = (input: string) =>
    input.length ? input[0].toUpperCase() + input.slice(1) : input;

  const clamp = (input: string, max: number) =>
    input.length <= max ? input : input.slice(0, max).trim();

  let candidate = sanitize(prompt ?? "");
  if (!candidate && voiceoverScript) {
    const firstLine =
      voiceoverScript.split(/\r?\n/).find((l) => sanitize(l).length > 0) ?? "";
    candidate = sanitize(firstLine);
  }

  candidate = candidate.replace(/[\s.,;:!?-]+$/g, "");
  candidate = capitalize(candidate);

  // YouTube title max length is 100 characters
  candidate = clamp(candidate, 100);

  if (!candidate) {
    throw new Error("Cannot build a non-empty YouTube title from inputs");
  }

  return candidate;
}

export const generateVideo = inngest.createFunction(
  { id: "generate-manim-video", timeouts: { start: "10m", finish: "10m" } },
  { event: "video/generate.request" },
  async ({ event, step }) => {
    const { prompt, userId, chatId, jobId } = event.data as {
      prompt: string;
      userId: string;
      chatId: string;
      jobId?: string;
    };

    console.log(`Starting video generation for prompt: "${prompt}"`);

    try {
      // Step 1: Generate voiceover narration
      const voiceoverScript = await step.run(
        "generate-voiceover-script",
        async () => {
          return await generateVoiceoverScript({ prompt });
        }
      );

      console.log("Generated voiceover script", {
        length: voiceoverScript.length,
      });

      // Steps 2-4: Generate Manim script, render, and upload
      // If an error occurs during these steps (e.g., due to a bad script),
      // retry from generating the Manim script onward ONCE, keeping the same voiceover.
      // let hasFailedOnce = false;  // testing error retrying capability
      let videoUrl: string | null = null;

      const result = await step.run(
        "generate-manim-script-and-render-and-upload",
        async () => {
          // if (!hasFailedOnce) {
          //   hasFailedOnce = true;
          //   console.log("Forcing failure on first run...");
          //   throw new Error("Intentional failure for retry test");
          // } // testing error retrying capability

          const script = await generateManimScript({ prompt, voiceoverScript });

          console.log("Generated Manim script", {
            scriptLength: script.length,
          });

          const dataUrlOrPath = await renderManimVideo({ script, prompt });

          videoUrl = await uploadVideo({
            videoPath: dataUrlOrPath,
            userId,
          });

          console.log("Video uploaded successfully:", videoUrl);

          return videoUrl;
        }
      );

      if (jobId) {
        await jobStore.setReady(jobId, videoUrl!);
      }

      // Fire-and-forget YouTube upload after UploadThing is ready
      const ytTitle = buildYouTubeTitle({ prompt, voiceoverScript });
      await step.sendEvent("dispatch-youtube-upload", {
        name: "video/youtube.upload.request",
        data: {
          videoUrl: videoUrl!,
          title: ytTitle,
          description: `Generated by scimath-vids for: ${prompt}`,
          jobId,
          userId,
        },
      });

      // Return the final result
      return {
        success: true,
        videoUrl: videoUrl!,
        prompt,
        userId,
        chatId,
        generatedAt: new Date().toISOString(),
        // We do not persist the script; expose voiceover length for traceability
        voiceoverLength: voiceoverScript.length,
      };
    } catch (err: any) {
      console.error("Error in generateVideo function:", err);
      if (jobId) {
        await jobStore.setError(jobId, err?.message ?? "Unknown error");
      }
      throw err;
    }
  }
);

export const uploadVideoToYouTube = inngest.createFunction(
  { id: "upload-video-to-youtube", timeouts: { start: "15m", finish: "30m" } },
  { event: "video/youtube.upload.request" },
  async ({ event, step }) => {
    const { videoUrl, title, description, jobId } = event.data as {
      videoUrl: string;
      title: string;
      description?: string;
      jobId?: string;
    };

    try {
      const yt = await step.run("upload-to-youtube", async () => {
        return await uploadToYouTube({
          videoUrl,
          title,
          description,
          tags: ["education", "manim", "math", "science"],
        });
      });

      await step.run("log-youtube-success", async () => {
        console.log("YouTube upload complete", yt);
      });

      // Optionally: you could persist yt.watchUrl back to job store as metadata in future
      return { success: true, ...yt };
    } catch (err: any) {
      await step.run("log-youtube-failure", async () => {
        console.error("YouTube upload failed", err);
      });
      if (jobId) {
        // Do NOT mark job error; frontend is already updated with UploadThing URL.
        // We only log the failure for YouTube background step.
      }
      throw err;
    }
  }
);
